using Primitives;

#if BRAINFUCK
alias BlockHeader u8;
const BlockHeader StatusFlag = 0x80 as BlockHeader;
const BlockHeader SizeMask = 0x7f as BlockHeader;
#else
alias BlockHeader u32;
const BlockHeader StatusFlag = 0x80000000 as BlockHeader;
const BlockHeader SizeMask = 0x7fffffff as BlockHeader;
#endif

#if BRAINFUCK
[External("heap_size")]
const int HeapSize = 127;
#else
[External("heap_size")]
const int HeapSize = 512;
#endif

const int HeaderSize = sizeof(BlockHeader);

[Internal("heap_start")]
const int HeapStart = 0;

[Builtin("init_heap")]
export inline void init_heap()
{
    if ((!#BRAINFUCK) && (!#IL))
    {
        *(HeapStart as BlockHeader*) = (BlockHeader)HeapSize;
    }
}

[MSILIncompatible]
void get_header(BlockHeader* headerPtr, int* size, bool* allocated)
{
    BlockHeader header = *headerPtr;
    if (header >= StatusFlag) // value & StatusFlag
    {
        *size = (int)(header - StatusFlag); // value & SizeMask
        *allocated = true;
    }
    else
    {
        *size = (int)header;
        *allocated = false;
    }
}

[MSILIncompatible]
inline void set_header_used(BlockHeader* headerPtr, int size)
{
    *headerPtr = (BlockHeader)size + StatusFlag;
}

[MSILIncompatible]
inline void set_header_free(BlockHeader* headerPtr, int size)
{
    *headerPtr = (BlockHeader)size;
}

[MSILIncompatible]
bool join_free_blocks()
{
    BlockHeader* headerPointer = HeapStart as BlockHeader*;
    int prevBlockSize = 0;
    while (headerPointer < HeapSize)
    {
        int blockSize;
        bool blockUsed;
        get_header(headerPointer, &blockSize, &blockUsed);

        if (headerPointer != 0 && !blockUsed)
        {
            BlockHeader* prevOffset = (headerPointer - prevBlockSize - HeaderSize) as BlockHeader*;

            int _temp;
            bool prevBlockUsed;
            get_header(prevOffset, &_temp, &prevBlockUsed);

            if (!prevBlockUsed)
            {
                set_header_free(prevOffset, blockSize + prevBlockSize + HeaderSize);
                *headerPointer = (BlockHeader)0;
                return true;
            }
        }

        prevBlockSize = blockSize;

        headerPointer += blockSize + HeaderSize;
    }
    return false;
}

[Expose("alloc")]
[Builtin("alloc")]
[MSILIncompatible]
export any* alloc(int sizeNeed)
{
#if IL
    crash "The function `alloc` is not compatible with MSIL";
#endif
    if (sizeNeed <= 0) { crash "Invalid size"; }

    BlockHeader* headerPointer = HeapStart as BlockHeader*;
    while (true)
    {
        if (headerPointer >= HeapSize) { crash "Out of memory"; }

        int blockSize;
        bool blockUsed;
        get_header(headerPointer, &blockSize, &blockUsed);
        any* dataPointer = (headerPointer + HeaderSize) as any*;

        if ((!blockUsed) && blockSize >= sizeNeed)
        {
            int _remainingSize = blockSize - sizeNeed - HeaderSize;

            if (_remainingSize > 0)
            {
                set_header_free((dataPointer + sizeNeed) as BlockHeader*, _remainingSize);
            }
            else
            {
                sizeNeed = blockSize;
            }

            set_header_used(headerPointer, sizeNeed);

            return dataPointer;
        }

        headerPointer += blockSize + HeaderSize;
    }
    return 0 as any*;
}

[Expose("resize")]
[MSILIncompatible]
export bool resize(any* ptr, int size)
{
#if IL
    crash "The function `resize` is not compatible with MSIL";
#endif
    if (size <= 0) { crash "Invalid size"; }
    if (!ptr) { return false; }

    BlockHeader* headerPointer = (ptr - HeaderSize) as BlockHeader*;

    int blockSize;
    bool blockUsed;
    get_header(headerPointer, &blockSize, &blockUsed);

    if (!blockUsed) { return false; }

    if (size > blockSize)
    {
        BlockHeader* nextHeader = (headerPointer + blockSize + HeaderSize) as BlockHeader*;
        if (headerPointer >= HeapSize) { return false; }

        int blockSizeNext;
        bool blockUsedNext;
        get_header(nextHeader, &blockSizeNext, &blockUsedNext);

        if (blockUsedNext) { return false; }

        int combinedSize = blockSizeNext + HeaderSize + blockSize;
        if (combinedSize < size) { return false; }

        int _remainingSize = combinedSize - size - HeaderSize;
        if (_remainingSize > 0)
        {
            set_header_free((ptr + size) as BlockHeader*, _remainingSize);
        }

        set_header_used(headerPointer, size);

        return true;
    }
    else if (size < blockSize)
    {
        int _remainingSize = blockSize - size - HeaderSize;

        if (_remainingSize > 0)
        {
            set_header_free((ptr + size) as BlockHeader*, _remainingSize);
        }

        set_header_used(headerPointer, size);

        return true;
    }
    else
    {
        return true;
    }

    return false;
}

[Builtin("free")]
[MSILIncompatible]
export void free(any* pointer)
{
#if IL
    crash "The function `free` is not compatible with MSIL";
#endif
    BlockHeader* headerPtr = (pointer as int - HeaderSize) as BlockHeader*;

    int size;
    bool allocated;

    get_header(headerPtr, &size, &allocated);

    if (!allocated)
    { return; }

    set_header_free(headerPtr, size);

    while (join_free_blocks()) { }
}
